"""提示模板管理器

提供标准化的提示模板，用于生成知识图谱数据。
"""

from typing import Dict, Any, Optional, List, Union
from .exceptions import PromptTemplateError
import os
import json

class PromptTemplate:
    """提示模板管理器"""

    def __init__(self, template_file: Optional[str] = None):
        """初始化提示模板管理器"""
        # 存储字符串格式模板
        self._templates = {
            "knowledge_graph_extraction": self._get_kg_extraction_template(),
            "knowledge_graph_extraction_easy": self._get_kg_extraction_easy_template()
        }
        
        # 存储 JSON messages 格式模板
        self._json_templates = {}
        
        # 设置默认模板
        self.default_template = "knowledge_graph_extraction_easy"
        self._is_default_json = False  # 标记默认模板是否为 JSON 格式
        
        if template_file:
            self.load_template_from_file(template_file)

    
    def get_template(self, template_name: str) -> Union[str, List[Dict[str, str]]]:
        """获取指定的提示模板
        
        Args:
            template_name: 模板名称
            
        Returns:
            提示模板字符串或 messages 列表
            
        Raises:
            PromptTemplateError: 当模板不存在时
        """
        # 优先从 JSON 模板中查找
        if template_name in self._json_templates:
            return self._json_templates[template_name]
        elif template_name in self._templates:
            return self._templates[template_name]
        else:
            raise PromptTemplateError(f"模板 '{template_name}' 不存在")
    
    def create_prompt(self, **kwargs) -> List[Dict[str, str]]:
        """创建完整的提示（统一返回 messages 格式）
        
        Args:
            **kwargs: 模板参数
            
        Returns:
            消息列表（messages 格式）
            
        Raises:
            PromptTemplateError: 当模板不存在或参数缺失时
        """
        template = self.get_template(self.default_template)
        
        try:
            # 如果模板是 JSON messages 格式
            if isinstance(template, list):
                return self._fill_messages_template(template, kwargs)
            
            # 如果模板是字符串格式，填充后转换为 messages
            else:
                filled_string = template.format(**kwargs)
                return self._string_to_messages(filled_string)
                    
        except KeyError as e:
            raise PromptTemplateError(f"模板参数缺失: {e}")
        except Exception as e:
            raise PromptTemplateError(f"创建提示失败: {e}")
    
    def _get_kg_extraction_template(self) -> str:
        """获取知识图谱抽取模板"""
        return """
### **一、任务概述**

**角色：** 你是一个专业的信息抽取系统。你的任务是仔细分析提供的文本，并根据下面列出的精确定义和规则，提取特定的实体、它们的状态以及这些状态之间的关系。准确性、确定性以及严格遵守源文本和格式规则至关重要。

**目标：** 提取与洪涝灾害及相关事件有关的以下信息：
1.  **基础实体：** 事件（Event）、地点（Location）、设施（Facility）。
2.  **状态实体：** 基础实体在特定时空下的状态（独立状态或联合状态）。
3.  **状态关系：** 状态实体间的因果联系。
**确保提取文本中明确提及或可直接推断的所有符合定义的地点、状态和关系实体。**
**关键指令：** **仅**提取文本中明确提及或可直接推断的信息。除非特别允许（例如，根据上下文推断年份），否则不要添加外部知识。如果对某项提取不确定，则**不要**包含它。

---

### **二、实体定义**

#### **A. 基础实体定义**

* **严格遵守：** 只提取完全符合这些定义和规则的实体。

| 实体类型          | 定义                                                                                                | 示例                                    | 明确排除项                                                                        |
| :---------------- | :-------------------------------------------------------------------------------------------------- | :-------------------------------------- | :---------------------------------------------------------------------------------- |
| **事件 (Event)** | 直接导致或由洪涝灾害引发的自然或衍生事件。**必须**能与文本中提到的特定时间和地点绑定。                | `2023年长江流域暴雨`、`某河段决堤事件`    | 缺乏具体时间/地点上下文的泛称（如“洪水”）、常规活动（如“每日报告”）。              |
| **地点 (Location)** | **1. 自然地理实体**（河流、湖泊等）或 **2. 行政区域**（省、市、区、乡镇）。必须与事件上下文相关。应使用文本中提到的**最具体**的名称。 | `长江`、`鄱阳湖`、`湖北省武汉市`        | 非地理实体（如“街道”，除非明确指定为行政单元如`新竹街道`）、非特定位置（如“下游”，除非是命名河段的一部分）。 |
| **设施 (Facility)** | 参与防洪、水资源管理或救灾的、具有**具体明确名称**的**人工建造结构**。必须具有可辨识的（即使是概括性的）物理位置。 | `三峡大坝`、`龙潭水库排水泵站`、`湘江水文站`          | 自然实体（如`长江`）、未命名结构（如“一个泵站”、“一段堤防”）、除非直接参与水管理的行政建筑（如“政府大楼”）。 |

#### **B. 状态实体定义**

* **背景：** 描述基础实体在*从文本中提取*的特定时空背景下的状况或状态。

独立状态 (Independent State):
定义：描述单一基础实体在特定时间或时间段内的状态。
特别说明： 如果一个状态描述（例如，总受灾人口、经济损失统计）明确归属于一个单一的、已识别的行政区域实体（无论其级别，例如 L-450000 代表 广西全区），则应提取为该实体的独立状态 (LS-...)。

联合状态 (Joint State):
定义：描述涉及多个基础实体的不可分割状态（例如，聚合统计数据、协同动作）。
触发条件：数据无法按单一实体拆分（如明确说明是 南宁市、北海市 的总受灾人口），或者多个实体被明确关联到一个共享的状态/动作中。
明确排除： 不应将仅针对单一高级别行政区（如 广西全区）报告的统计数据视为联合状态，除非文本明确指明该数据是其下属多个具体列出的市/县/区等实体的联合统计结果。
---

### **三、抽取规则与流程**

#### **A. 推荐抽取顺序**

1.  **识别潜在事件：** 扫描与洪涝灾害相关的关键词（例如，`暴雨`、`洪水`、`台风`、`决堤`、`内涝`、`山体滑坡`、`泄洪`）。
2.  **抽取事件：** 如果找到关键词，验证它是否与文本中的特定时间和地点相关联。如果是，则作为事件实体提取。
3.  **抽取地点与设施：** 识别所有与已提取事件或灾害背景相关的、已命名的地点（自然地理、行政区域）和已命名的设施。严格应用排除规则。
4.  **抽取状态：** 对于每个识别出的基础实体，查找文本中描述其状况、条件或行为，并与特定时间相关联的信息。根据状态是适用于一个实体还是多个不可分割的实体，判断其为独立状态还是联合状态。
5.  **抽取关系：** 识别**已提取的状态实体**之间明确的因果或顺序联系。查找诸如`导致`、`引发`、`因为`、`由于`、`影响`、`造成`、`随着`、`然后`等关键词。关系必须连接两个**特定的状态ID**。
    * **【重要约束 - 范围与逻辑检查】** 在建立因果关系（尤其是`导致`、`引发`、`造成`）时，必须进行以下检查：
        * **范围匹配：** 主体状态（原因）的地理或影响范围应与客体状态（结果）的范围具有逻辑上的匹配性。避免将极其局部的状态（如单一乡镇的雨量）直接关联为导致极其广泛状态（如多市受灾）的原因，除非文本有明确无误的强关联描述。
        * **区分示例与原因：** 注意识别文本中作为“示例”、“其中”、“特别是”等引出的局部极端状态。这些通常是整体事件的表现，而非后续大范围结果的直接原因。
        * **优先关联整体事件/状态：** 对于广泛的灾害后果，优先将其关联到能覆盖该范围的整体事件状态或相应的中间状态（如大范围洪水）。例如，文本“广西发生强降雨过程（事件状态A），其中罗锦镇雨量最大（局部状态B），导致12个市受灾（广泛状态C）”，应优先提取关系 `A 导致 C`（如果文本支持）或寻找中间状态 D（如洪水状态）建立 `A 导致 D` 和 `D 导致 C`，而**避免**提取 `B 导致 C`。
        * **时间逻辑一致性：** 主体状态（原因）的时间段必须在逻辑上 **先于或包含** 客体状态（结果）的时间段内发生。**严禁**将仅发生在特定较短时间段（如“6月底至7月初”）的事件状态，关联为导致一个明确覆盖了更长或不同时间范围（尤其是明确标示为 `全年`、`年度` 等）的状态的直接原因。必须仔细核对状态对应的时间信息。
        * **避免自身关联：** 避免将一个状态实体关联到其自身，即 `A 导致 A`。
#### **B. 关键规则与约束**

* **严格命名：**
    * **设施：** 必须具有具体名称（例如 `三峡大坝`）。不要提取通用术语，如“水库”或“堤防”，除非它们是特定名称的一部分（例如，`长江堤防`可被视为与`长江`相关的特定命名设施）。需要判断：它指的是一般概念还是特定的、已命名的结构。如果不确定，则**不提取**。
    * **地点：** 使用提供的最具体名称（例如，如果提到`昆仑镇`，就提取它，而不仅仅是`兴宁区`）。避免提取模糊的量词，如`5个市`，除非具体的城市在*紧邻的上下文*中列出或明确暗示。不要将`全区`这样的术语扩展为行政单位列表，除非文本提供了该列表。
* **自然地理实体 vs. 设施：** 两者是不同的。`长江`是`地点`。`长江堤防`是沿该地点建造的`设施`。如果两者都被提及并扮演相关角色，则都提取。
* **时间标准化：**
    * 格式：始终使用 `YYYY-MM-DD`。
    * 单一日期：`YYYY年M月D日 -> YYYY-MM-DD至YYYY-MM-DD`。示例：`2023年6月1日 -> 2023-06-01到2023-06-01`。
    * 日期范围：`M月D1日-D2日` -> 从上下文推断年份 -> `YYYY-MM-DD1` 到 `YYYY-MM-DD2`。示例：`6月10-16日`（假设上下文暗示为2023年）-> `2023-06-10至2023-06-16`。
    * 仅有月份/年份：如果只给出月份/年份（例如 `2023年10月`），则将范围表示为整个月：`2023-10-01至2023-10-31`。
    * **确定性：** 只提取和标准化明确提及的时间。不要猜测日期。
* **确定性原则：** 如果一条信息含糊不清或不明确符合定义/规则，则**不要提取**。优先考虑准确性而非召回率。
* **状态覆盖关联：** 在识别出基础实体（地点、事件、设施）后，应尽力查找并提取其在文本中对应的具体状态描述（状况、条件、行为等）和时间信息。**尽可能避免仅提取了基础实体而未能提取其任何相关状态实体的情况。** 一个基础实体如果被提及，通常应有关联的状态信息需要提取。
* **覆盖所有实体类型：** 状态和关系的提取必须平等地覆盖所有类型的基础实体，包括事件（Event）、设施（Facility）以及**所有类型的地点（Location）**。特别注意，对于河流、湖泊、山脉等**自然地理实体**，如果文本描述了它们的状态（如水位、流量、发生滑坡等）或与其他状态的关系，**必须**同样进行提取，不能遗漏。
* **重视上下文标识符：** 在提取信息时，必须高度关注并利用文本周围的上下文信息，如**表格标题（例如，“表 2-4 水利设施全年受损统计表”中的“全年”）、图表说明、章节标题和小节编号（例如，“（三）主要过程”、“1．6 月底到 7 月初暴雨洪涝灾害”）**等。这些标识符通常定义了信息的作用域、时间范围或性质。提取的状态和关系必须严格符合这些上下文标识符所限定的范围和时间。例如，从标记为“全年”的表格中提取的状态，其时间范围应是对应的整个年份，并且不能被错误地归因于该年份中的某一个特定短期事件。
---

### **四、ID 设计与消歧**

* **准确性是关键：** 严格按照这些格式生成ID。
* **处理缺失的行政区划码：** 如果无法从文本或您可访问的通用地理知识中可靠地确定`行政区划码`，请使用占位符`UNKNOWN`（例如 `L-UNKNOWN>某个镇`）。如果可以合理推断（例如，知道“南宁”在“广西”），则优先使用代码。

#### **A. 基础实体 ID 设计**

* **事件 ID:** `E-<行政区划码>[>乡镇街道等子区域]-<日期YYYYMMDD>-<事件类型>`
    * 消歧：地点（最具体的行政区划码+可选子区域）、开始日期和事件类型（例如 `TYPHOON`, `FLOOD`, `RAIN`, `LANDSLIDE`, `DIKE_BREACH`）的唯一组合。
    * 示例：`E-450102>昆仑镇-20231001-LANDSLIDE`（2023年10月1日南宁市兴宁区(450102)昆仑镇的山体滑坡）
* **地点 ID:**
    * 行政区域: `L-<行政区划码>[>乡镇街道等子区域]`
    * 自然实体: `L-<实体类型>-<名称>[>区段]` (实体类型: 例如 `RIVER`, `LAKE`)
    * 消歧：行政区划码+子区域级别 / 实体类型+名称+可选区段。
    * 示例：`L-450102>昆仑镇`（兴宁区昆仑镇）、`L-RIVER-桂江>阳朔县城河段`（桂江，阳朔县城河段）
    * 补充说明： 对于明确指代单一、完整的省级、自治区级或直辖市级行政区域的术语（如 全省、全区、全市 后面跟着省级/自治区级/直辖市级名称，例如 广西全区、湖北全省），应将其视为一个独立的地点实体，代表该最高级别的行政单位本身（例如，广西壮族自治区，对应ID L-450000）。不应自动将其视为其下属所有子区域的集合，除非文本明确列出了这些子区域并说明状态是这些子区域的联合状态。
* **设施 ID:** `F-<行政区划码>[>乡镇街道等子区域]-<设施名称>`
    * 消歧：地点上下文（行政区划码+子区域）+设施名称。
    * 示例：`F-450102>昆仑镇-群星村水坝`（兴宁区昆仑镇群星村水坝）

#### **B. 状态实体 ID 设计**

* **事件状态 ID:** `ES-<事件ID>-<开始日期YYYYMMDD>_<结束日期YYYYMMDD>` (描述**事件本身**的状态)
    * 示例：`ES-E-450000-20231001-TYPHOON-20231001_20231010` (2023年10月1日至10日广西台风事件的状态)
* **地点状态 ID:** `LS-<地点ID>-<开始日期YYYYMMDD>_<结束日期YYYYMMDD>` (描述**某个地点**的状态)
    * 示例：`LS-L-450103>新竹街道-20231001_20231010` (2023年10月1日至10日新竹街道的状态，例如报告了伤亡)
    * 示例：`LS-L-450100-20231004_20231004` (仅2023年10月4日南宁市的状态，如来自图片说明)
* **设施状态 ID:** `FS-<设施ID>-<开始日期YYYYMMDD>_<结束日期YYYYMMDD>` (描述**某个设施**的状态)
    * 示例：`FS-F-450102>昆仑镇-群星村水坝-20231003_20231003` (仅2023年10月3日群星村水坝的状态，例如正在泄洪)
* **联合状态 ID:** `JS-<关联的基础实体ID列表>-<开始日期YYYYMMDD>_<结束日期YYYYMMDD>` (使用基础实体ID: L-, F-)
    * 示例：`JS-L-450100-L-450500-20231001_20231010` (2023年10月1日至10日南宁(L-450100)和北海(L-450500)的联合状态，例如合并统计数据)

---

### **五、输出格式**

* **严格 JSON:** **仅**以以下有效的 JSON 格式提供输出。确保所有键名和期望的值类型都匹配。

```json
{{
  "基础实体": [ // 基础实体列表
    {{
      "类型": "事件/地点/设施",       // 例如: "地点"
      "名称": "标准化名称",           // 例如: "南宁市"
      "唯一ID": "按照规则生成的ID",    // 例如: "L-450100"
      "地理描述": "文本中关于地理位置的描述" // 例如: "广西南宁市" (地点和设施需要此字段)；当地点是自然实体或者设施时，请依据上下文在地理描述中加入相关行政区划，如："广西湘江"，以防止同名自然实体歧义等情况。
    }}
    // ... 更多基础实体
  ],
  "状态实体": [ // 状态实体列表
    {{
      "类型": "独立状态/联合状态",     // 例如: "联合状态"
      "关联实体ID列表": ["基础实体ID列表"], // 例如: ["L-450100", "L-450500"] (独立状态一个ID，联合状态多个ID，请都使用列表格式)
      "状态ID": "唯一状态标识符",         // 例如: "JS-L-450100-L-450500-20231001_20231010" (注意时间段格式)
      "时间": "YYYY-MM-DD至YYYY-MM-DD", // 例如: "2023-10-01至2023-10-10"
      "状态描述": {{                  // 描述该状态的字典
        "属性1": "值1",              // 例如: "总受灾人口": "52.88万人"
        "属性2": "值2"               // 例如: "直接经济损失": "3.90亿元"
        // ... 从文本提取的更多属性
      }}
      // **** 重要格式约束 (Neo4j 兼容性) ****：
      // 1.  **值必须是基础类型:** 此 `状态描述` 字典内的 **所有值** 必须是 **基础数据类型**（字符串 String, 数字 Number, 布尔值 Boolean）。
      // 2.  **严禁嵌套 Map/Object:** **绝不允许** 任何属性的值是另一个字典或映射（Map/Object）。
      // 3.  **处理结构化数据（如表格）:** 如果原始信息来自具有子分类或子列的结构（例如表格中某列下还有细分），必须将其 **扁平化 (Flatten)** 处理为多个独立的键值对。
      //     * **方法:** 通过组合键名（例如使用下划线 `_` 连接原有多级列名）来创建唯一的、描述性的属性名。
      //     * **错误示例 (导致 Neo4j 报错):** `{{"损坏水库": {{"大中型/座": 0, "小型/座": 0}}}}`
      //     * **正确示例 (扁平化后):** `{{"损坏水库_大中型/座": 0, "损坏水库_小型/座": 0}}` 或者 `{{"损坏水库大中型数量": 0, "损坏水库小型数量": 0}}` （选择清晰易懂的组合方式）
    }}
    // ... 更多状态实体
  ],
  "状态关系": [ // 状态关系列表
    {{
      "主体状态ID": "源头状态的ID",       // 例如: "ES-E-450000-20231001-TYPHOON-20231001_20231010" (原因/起点状态, 注意时间段格式)
      "关系": "触发/影响/调控/导致", // 例如: "导致" (关系类型)
      "客体状态ID": "结果状态的ID",       // 例如: "JS-L-450100-L-450500-20231001_20231010" (影响/结果状态, 注意时间段格式)
      "依据": "原文中描述关系的片段" // 例如: "台风导致广西南宁市、北海市总受灾人口达52.88万人" (支持关系的文本片段)
      // **** 重要要求 ****："依据"字段的值 **必须** 是直接从输入文本中复制的支持该关系判断的关键句子或短语。
    }}
    // ... 更多状态关系
  ]
}}
```

------

### **六、验证示例**

- **使用此示例来理解所有规则的应用。**

#### **输入文本:**

```
2023年10月1日到10日，台风导致广西南宁市、北海市总受灾人口达52.88万人，直接经济损失达3.90亿元；南宁市青秀区新竹街道死亡5人。同期10月3日三峡大坝泄洪量达5000立方米/秒，长江荆江河段水位上升0.2米。
![](images/f4bcf52e1b923e94408c147bafca749290036271a7c4f4c8391131e76ad120c1.jpg)
图 2-11 南宁市洪涝灾害（10月4日）
```

#### **预期输出:**


```json
{{
  "基础实体": [
    {{
      "类型": "事件",
      "名称": "2023年10月广西台风事件", // 根据上下文构建的名称
      "唯一ID": "E-450000-20231001-TYPHOON", // 广西代码: 450000, 日期: 20231001, 类型: TYPHOON
      "地理描述": "广西南宁市、北海市" // 文本提及的影响区域
    }},
    {{
      "类型": "地点",
      "名称": "南宁市",
      "唯一ID": "L-450100", // 南宁市代码: 450100
      "地理描述": "广西南宁市"
    }},
    {{
      "类型": "地点",
      "名称": "北海市",
      "唯一ID": "L-450500", // 北海市代码: 450500
      "地理描述": "广西北海市"
    }},
    {{
      "类型": "地点",
      "名称": "新竹街道",
      "唯一ID": "L-450103>新竹街道", // 青秀区代码: 450103, 子区域: 新竹街道
      "地理描述": "南宁市青秀区新竹街道"
    }},
    {{
      "类型": "设施",
      "名称": "三峡大坝",
      "唯一ID": "F-420500-三峡大坝", // 宜昌市代码 (大坝所在地): 420500 , 注意设施ID有两个短横, 注意与地点ID的区别
      "地理描述": "湖北三峡大坝" // 从文本提取的描述 (若有更多信息可补充)
    }},
    {{
      "类型": "地点",
      "名称": "长江>荆江河段",
      "唯一ID": "L-RIVER-长江>荆江河段", // 自然实体: 河流, 名称: 长江, 区段: 荆江河段
      "地理描述": "湖北长江荆江河段"
    }}
  ],
  "状态实体": [
    {{
      "类型": "独立状态", // 事件本身的状态
      "关联实体ID列表": ["E-450000-20231001-TYPHOON"],
      "状态ID": "ES-E-450000-20231001-TYPHOON-20231001_20231010", // 使用事件的完整时间段
      "时间": "2023-10-01至2023-10-10",
      "状态描述": {{
        "事件类型": "台风",
        "影响范围": "广西南宁市、北海市"
      }}
    }},
    {{
      "类型": "联合状态", // 南宁市和北海市的联合状态
      "关联实体ID列表": ["L-450100", "L-450500"],
      "状态ID": "JS-L-450100-L-450500-20231001_20231010", // 使用影响期的完整时间段
      "时间": "2023-10-01至2023-10-10",
      "状态描述": {{
        "总受灾人口": "52.88万人",
        "直接经济损失": "3.90亿元"
      }}
    }},
    {{
      "类型": "独立状态", // 特定街道地点的状态
      "关联实体ID列表": ["L-450103>新竹街道"],
      "状态ID": "LS-L-450103>新竹街道-20231001_20231010", // 使用影响期的完整时间段 (假设死亡发生在事件期间)
      "时间": "2023-10-01至2023-10-10", // 假设死亡发生在事件期间
      "状态描述": {{
        "死亡人数": 5
      }}
    }},
    {{
      "类型": "独立状态", // 设施的状态
      "关联实体ID列表": ["F-420500-三峡大坝"],
      "状态ID": "FS-F-420500-三峡大坝-20231003_20231003", // 泄洪是特定日期的动作
      "时间": "2023-10-03至2023-10-03",
      "状态描述": {{
        "泄洪量": "5000立方米/秒",
        "操作": "泄洪" // 从“泄洪量”推断出的动作
      }}
    }},
     {{
      "类型": "独立状态", // 河段地点的状态
      "关联实体ID列表": ["L-RIVER-长江>荆江河段"],
      "状态ID": "LS-L-RIVER-长江>荆江河段-20231003_20231003", // 水位上升是特定日期的结果
      "时间": "2023-10-03至2023-10-03", // 假设水位上升与原因(10月3日)同时或紧随其后发生
      "状态描述": {{
        "水位变化": "上升0.2米"
      }}
    }},
    {{
      "类型": "独立状态", // 从图片说明中提取的状态
      "关联实体ID列表": ["L-450100"],
      "状态ID": "LS-L-450100-20231004_20231004", // 图片说明是特定日期的状态
      "时间": "2023-10-04至2023-10-04",
      "状态描述": {{
        "灾害类型": "洪涝灾害", // 来自图片说明文字
        "证据": "图 2-11", // 引用图号
        "图片路径": "images/f4bcf52e1b923e94408c147bafca749290036271a7c4f4c8391131e76ad120c1.jpg" // 假设路径是相关信息
      }}
    }}
  ],
  "状态关系": [
    {{
      "主体状态ID": "ES-E-450000-20231001-TYPHOON-20231001_20231010", // 台风事件状态 
      "关系": "导致", // 文本中使用了“导致”
      "客体状态ID": "JS-L-450100-L-450500-20231001_20231010", // 损失的联合状态 
      "依据": "台风导致广西南宁市、北海市总受灾人口达52.88万人，直接经济损失达3.90亿元"
    }},
    {{
      "主体状态ID": "ES-E-450000-20231001-TYPHOON-20231001_20231010", // 台风事件状态 
      "关系": "导致", // 在同一事件背景/时期内，死亡的因果关系是隐含的
      "客体状态ID": "LS-L-450103>新竹街道-20231001_20231010", // 街道死亡人数的状态 
      "依据": "台风导致广西南宁市、北海市总受灾人口达52.88万人，直接经济损失达3.90亿元；南宁市青秀区新竹街道死亡5人" // 连接事件和具体后果
    }},
    {{
      "主体状态ID": "FS-F-420500-三峡大坝-20231003_20231003", // 大坝泄洪状态 
      "关系": "导致", // 隐含的因果关系
      "客体状态ID": "LS-L-RIVER-长江>荆江河段-20231003_20231003", // 河流水位上升状态 
      "依据": "同期10月3日三峡大坝泄洪量达5000立方米/秒，长江荆江河段水位上升0.2米"
    }}
  ]
}}
```

---

### 
待处理文本：
以下数据均来自于《{doc_name}》
{chunk}

请返回严格符合上述规则的JSON。**务必提取所有的地点、状态、关系实体。**不要包含其他解释性文字。
"""

    def _get_kg_extraction_easy_template(self) -> str:
        """获取KG提取模板（简单版）

        Returns:
            str: KG提取模板
        """
        return """
**角色与任务**

你是一个高度专业化的信息抽取引擎，专为洪涝灾害领域设计。你的核心任务是**精确、无遗漏地**从给定文本中抽取出符合下列严格定义的实体、状态和关系，并以指定的JSON格式输出。**准确性和对规则的绝对遵守是最高优先级。**

---

### **一、核心原则（必须严格遵守）**

1.  **忠于原文 (Grounding in Source)**: **仅能**提取文本中明确陈述或可直接、无歧义推断的信息。**严禁**引入任何外部知识（如，根据其他文档推断事实），除非是通用地理编码（如“南宁市”对应“450100”）。
2.  **确定性优先 (Certainty First)**: 如果对某项信息的提取（实体、状态、关系）存在任何模糊或不确定性，**必须放弃提取**。宁可漏提，也不可错提。
3.  **无情景假设 (No Assumptions)**: 不要对文本中未明确提及的时间、地点或因果关系进行猜测。例如，如果一个状态没有明确的时间，则不能提取。
4.  **完整性扫描 (Complete Coverage)**: 必须扫描全文，确保**所有**符合定义的事件、地点（行政区、自然地理实体）、设施、状态及其关系都被提取。特别注意不要遗漏对河流、湖泊等自然实体的状态描述。
5.  **遵循上下文 (Context is Key)**: 必须利用文本中的**所有**上下文线索，如图表标题、章节标题（如“（三）全年灾情统计”）、脚注等，来确定信息（尤其是时间范围）的正确归属。

---

### **二、实体与状态定义**

#### **A. 基础实体定义**

| 实体类型            | 定义                                                         | 示例                               | 明确排除项                                       |
| :------------------ | :----------------------------------------------------------- | :--------------------------------- | :----------------------------------------------- |
| **事件 (Event)**    | 直接导致或由洪涝灾害引发的具体自然或衍生现象。**必须**能与文本中特定的时间和地点绑定。 | `2023年长江流域暴雨`、`某水库决堤` | 泛指（“洪水”）、常规活动（“每日简报”）。         |
| **地点 (Location)** | **1. 自然地理实体**（河流、湖泊等）或 **2. 行政区域**（省、市、区、乡镇）。必须与事件相关，并使用文本中**最具体**的名称。 | `长江`、`鄱阳湖`、`湖北省武汉市`   | 非特定位置（“下游”）、非行政单元（“北京西路”）。 |
| **设施 (Facility)** | 具有**具体名称**的、参与水利或救灾的**人造结构**。           | `三峡大坝`、`湘江水文站`           | 未命名结构（“一座泵站”）、自然实体（`长江`）。   |

#### **B. 状态实体定义**

* **独立状态 (Independent State)**: 描述**单一**基础实体在特定时空下的状况。
* **联合状态 (Joint State)**: 描述**多个**基础实体不可分割的共享状态（如“南宁、北海两市总损失...”）。**注意**：仅针对单个高级行政区（如“广西全区”）的统计数据是其自身的**独立状态**，除非文本明确指出这是其下属多个具体市县的联合统计。

---

### **三、思维链与抽取指令 (Chain-of-Thought & Extraction Instructions)**

**你必须在内部按以下步骤思考和执行任务：**

**Step 1: 识别基础实体 (Identify Base Entities)**

* 通读文本，找出所有符合定义的`事件`、`地点`（行政区和自然地理）和`设施`。
* 为每个识别出的实体，根据「ID设计规则」生成其唯一的`唯一ID`。

**Step 2: 抽取状态实体 (Extract State Entities)**

* 再次遍历文本，对于**每一个**在Step 1中识别出的基础实体，查找并提取描述其状况的文本，确保状态归属最细粒度原则(Most Granular Attribution Principle)：任何一个状态信息（如降雨量、受灾人口、水位等）**必须**关联到它所能描述的**最具体、最精确**的那个“基础实体”上。
* 确定该状态是`独立状态`还是`联合状态`。
* 提取状态关联的**精确时间范围**，并按`YYYY-MM-DD至YYYY-MM-DD`格式化。
* 将状态的描述性信息（如“受灾人口”、“水位”）组织成一个**扁平化的键值对字典**（`状态描述`）。
* 根据「ID设计规则」生成唯一的`状态ID`。

**Step 3: 抽取状态关系 (Extract State Relationships)**

* 在所有已提取的**状态实体**之间，寻找明确的因果或顺序联系。查找如`导致`、`引发`、`因为`、`造成`、`影响`等关键词。
* **【关键逻辑检查】** 对于每一个潜在的“导致”关系（从 `状态A` 到 `状态B`），必须执行以下**全部**检查：
  * **时间检查**: `状态A` 的时间必须早于或包含 `状态B` 的时间。**严禁**将短期事件（如“6月底暴雨”）作为全年损失的直接原因。
  * **范围检查**: `状态A` 的影响范围在逻辑上必须能覆盖 `状态B`。避免将局部状态（`某乡镇降雨`）关联为大范围结果（`多市受灾`）的原因，除非文本有极强的直接联系词句。优先将结果关联至范围更匹配的上游原因（如整个`暴雨过程`）。
  * **自反检查**: `状态A` 和 `状态B` 不能是同一个状态。
* 如果检查通过，则记录该关系，包括主体/客体状态ID、关系类型以及**支持该关系的原句**作为`依据`。

---

### **四、ID设计与输出格式**

#### **A. ID 设计（严格遵守）**

* **事件 ID**: `E-<行政区划码>-<日期YYYYMMDD>-<事件类型>` (e.g., `E-450000-20231001-TYPHOON`)
* **地点 ID**: `L-<行政区划码>[>子区域]` (行政区) 或 `L-<实体类型>-<名称>[>区段]` (自然实体) (e.g., `L-450103>新竹街道`, `L-RIVER-长江>荆江河段`)
* **设施 ID**: `F-<行政区划码>-<设施名称>` (e.g., `F-420500-三峡大坝`)
* **状态 ID**: `(ES|LS|FS|JS)-<关联实体ID(s)>-<开始日期YYYYMMDD>_<结束日期YYYYMMDD>[-<状态主题>]`
    * **【关键规则】ID唯一性处理**: 默认情况下，不使用`<状态主题>`。但是，如果一个实体在完全相同的起止时间内存在多个必须区分的独立状态，则**必须**为第二个及以后的状态ID添加后缀 `-<状态主题>` 来保证唯一性。
    * **`<状态主题>`生成**: 主题从此状态的 `状态描述` 字典中选取最核心的**键名(key)**，并将其转换为简短的标识符（如拼音首字母 `ZJJJSS` 代表 “直接经济损失”）。
    * **示例**:
        * `FS-F-420500-三峡大坝-20231003_20231003-XL` (泄洪量)
        * `FS-F-420500-三峡大坝-20231003_20231003-SW` (水位)
* 处理缺失行政区划码：使用 `UNKNOWN` 占位符。

#### **B. JSON 输出格式（最终且唯一的输出形式）**

* **必须**是单个、结构完整的JSON对象。
* **状态描述扁平化 (Flattening)**: `状态描述` 字典的值**必须**是字符串、数字或布尔值。**严禁**嵌套对象。
  * **错误示例 (会报错)**: `{{"损坏水库": {{"小型/座": 2}}}}`
  * **正确做法 (扁平化)**: `{{"损坏水库_小型/座": 2}}` 或 `{{"损坏水库小型数量": 2}}`

```json
{{
  "基础实体": [
    {{
      "类型": "事件/地点/设施",
      "名称": "标准化名称",
      "唯一ID": "生成的唯一ID",
      "地理描述": "文本中关于地理位置的描述"
    }}
  ],
  "状态实体": [
    {{
      "类型": "独立状态/联合状态",
      "关联实体ID列表": ["一个或多个基础实体ID"],
      "状态ID": "唯一状态标识符",
      "时间": "YYYY-MM-DD至YYYY-MM-DD",
      "状态描述": {{
        "扁平化属性1": "值1",
        "扁平化属性2": "值2"
      }}
    }}
  ],
  "状态关系": [
    {{
      "主体状态ID": "原因状态的ID",
      "关系": "关系类型",
      "客体状态ID": "结果状态的ID",
      "依据": "原文中支持该关系的关键句"
    }}
  ]
}}
```

------



### **五、验证示例 (用于校准你的理解)**



- **输入文本:**

  ```
  2023年10月1日到10日，台风导致广西南宁市、北海市总受灾人口达52.88万人，直接经济损失达3.90亿元；南宁市青秀区新竹街道死亡5人。同期10月3日三峡大坝泄洪量达5000立方米/秒，长江荆江河段水位上升0.2米。
  ![](images/f4bcf52e1b923e94408c147bafca749290036271a7c4f4c8391131e76ad120c1.jpg)
  图 2-11 南宁市洪涝灾害（10月4日）
  ```

- **预期输出 (这是你学习和模仿的范例):**

  JSON

  ```
  {{
    "基础实体": [
      {{"类型": "事件", "名称": "2023年10月广西台风事件", "唯一ID": "E-450000-20231001-TYPHOON", "地理描述": "广西南宁市、北海市"}},
      {{"类型": "地点", "名称": "南宁市", "唯一ID": "L-450100", "地理描述": "广西南宁市"}},
      {{"类型": "地点", "名称": "北海市", "唯一ID": "L-450500", "地理描述": "广西北海市"}},
      {{"类型": "地点", "名称": "新竹街道", "唯一ID": "L-450103>新竹街道", "地理描述": "南宁市青秀区新竹街道"}},
      {{"类型": "设施", "名称": "三峡大坝", "唯一ID": "F-420500-三峡大坝", "地理描述": "湖北三峡大坝"}},
      {{"类型": "地点", "名称": "长江>荆江河段", "唯一ID": "L-RIVER-长江>荆江河段", "地理描述": "湖北长江荆江河段"}}
    ],
    "状态实体": [
      {{"类型": "独立状态", "关联实体ID列表": ["E-450000-20231001-TYPHOON"], "状态ID": "ES-E-450000-20231001-TYPHOON-20231001_20231010", "时间": "2023-10-01至2023-10-10", "状态描述": {{"事件类型": "台风", "影响范围": "广西南宁市、北海市"}}}},
      {{"类型": "联合状态", "关联实体ID列表": ["L-450100", "L-450500"], "状态ID": "JS-L-450100-L-450500-20231001_20231010", "时间": "2023-10-01至2023-10-10", "状态描述": {{"总受灾人口": "52.88万人", "直接经济损失": "3.90亿元"}}}},
      {{"类型": "独立状态", "关联实体ID列表": ["L-450103>新竹街道"], "状态ID": "LS-L-450103>新竹街道-20231001_20231010", "时间": "2023-10-01至2023-10-10", "状态描述": {{"死亡人数": 5}}}},
      {{"类型": "独立状态", "关联实体ID列表": ["F-420500-三峡大坝"], "状态ID": "FS-F-420500-三峡大坝-20231003_20231003", "时间": "2023-10-03至2023-10-03", "状态描述": {{"泄洪量": "5000立方米/秒", "操作": "泄洪"}}}},
      {{"类型": "独立状态", "关联实体ID列表": ["L-RIVER-长江>荆江河段"], "状态ID": "LS-L-RIVER-长江>荆江河段-20231003_20231003", "时间": "2023-10-03至2023-10-03", "状态描述": {{"水位变化": "上升0.2米"}}}},
      {{"类型": "独立状态", "关联实体ID列表": ["L-450100"], "状态ID": "LS-L-450100-20231004_20231004", "时间": "2023-10-04至2023-10-04", "状态描述": {{"灾害类型": "洪涝灾害", "证据": "图 2-11", "图片路径": "images/f4bcf52e1b923e94408c147bafca749290036271a7c4f4c8391131e76ad120c1.jpg"}}}}
    ],
    "状态关系": [
      {{"主体状态ID": "ES-E-450000-20231001-TYPHOON-20231001_20231010", "关系": "导致", "客体状态ID": "JS-L-450100-L-450500-20231001_20231010", "依据": "台风导致广西南宁市、北海市总受灾人口达52.88万人，直接经济损失达3.90亿元"}},
      {{"主体状态ID": "ES-E-450000-20231001-TYPHOON-20231001_20231010", "关系": "导致", "客体状态ID": "LS-L-450103>新竹街道-20231001_20231010", "依据": "台风导致广西南宁市、北海市总受灾人口达52.88万人，直接经济损失达3.90亿元；南宁市青秀区新竹街道死亡5人"}},
      {{"主体状态ID": "FS-F-420500-三峡大坝-20231003_20231003", "关系": "导致", "客体状态ID": "LS-L-RIVER-长江>荆江河段-20231003_20231003", "依据": "同期10月3日三峡大坝泄洪量达5000立方米/秒，长江荆江河段水位上升0.2米"}}
    ]
  }}
  ```

------



### **执行任务**



**请严格遵循以上所有原则、定义、流程和格式，处理以下文本。返回唯一的、格式正确的JSON输出，不要包含任何解释性文字。**

来源文档: 《{doc_name}》

待处理文本:

{chunk}
        """

    def _fill_messages_template(self, messages: List[Dict[str, str]], params: Dict[str, Any]) -> List[Dict[str, str]]:
        """填充 messages 模板中的参数（仅填充最后一个消息）
        
        只在最后一个消息中填充参数，前面的 system 和 few-shot 示例保持不变。
        这样可以避免 JSON 示例中的双花括号被错误处理。
        
        Args:
            messages: 消息列表模板
            params: 参数字典
            
        Returns:
            填充后的消息列表
        """
        filled_messages = []
        
        for i, msg in enumerate(messages):
            if i < len(messages) - 1:
                # 前面的消息（system 和 few-shot）保持不变
                filled_messages.append({
                    "role": msg["role"],
                    "content": msg["content"]
                })
            else:
                # 最后一个消息，填充参数
                content = msg["content"]
                
                # 只替换模板中的参数占位符
                for key, value in params.items():
                    placeholder = "{" + key + "}"
                    content = content.replace(placeholder, str(value))
                
                filled_messages.append({
                    "role": msg["role"],
                    "content": content
                })
        
        return filled_messages
    
    def _messages_to_string(self, messages: List[Dict[str, str]]) -> str:
        """将 messages 格式转换为字符串格式
        
        Args:
            messages: 消息列表
            
        Returns:
            合并后的字符串
        """
        parts = []
        for msg in messages:
            role = msg["role"].upper()
            content = msg["content"]
            parts.append(f"[{role}]\n{content}")
        return "\n\n".join(parts)
    
    def _string_to_messages(self, text: str) -> List[Dict[str, str]]:
        """将字符串格式转换为 messages 格式
        
        Args:
            text: 提示文本字符串
            
        Returns:
            消息列表
        """
        # 简单实现：将整个文本作为 user 消息
        # 如果需要更复杂的分割逻辑，可以在这里扩展
        return [
            {"role": "user", "content": text}
        ]

    def set_default_template(self, template_name: str):
        """设置默认模板

        Args:
            template_name: 模板名称
        """
        if template_name not in self._templates and template_name not in self._json_templates:
            raise PromptTemplateError(f"模板不存在: {template_name}")
        self.default_template = template_name
        self._is_default_json = template_name in self._json_templates

    def add_template(self, name: str, template: Union[str, List[Dict[str, str]]]):
        """添加新的模板
        
        Args:
            name: 模板名称
            template: 模板内容（字符串或 messages 列表）
        """
        if isinstance(template, list):
            self._json_templates[name] = template
        else:
            self._templates[name] = template

    def load_template_from_file(self, file_path: str):
        """从文件加载模板

        Args:
            file_path: 模板文件路径（支持 .txt 和 .json 格式）
        """
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                # 判断文件类型
                if file_path.endswith('.json'):
                    # JSON 格式：期望是 messages 数组
                    data = json.load(f)
                    if isinstance(data, list):
                        # 验证是否为有效的 messages 格式
                        for msg in data:
                            if not isinstance(msg, dict) or 'role' not in msg or 'content' not in msg:
                                raise PromptTemplateError(f"无效的 JSON messages 格式: {file_path}")
                        template = data
                    else:
                        raise PromptTemplateError(f"JSON 文件必须包含 messages 数组: {file_path}")
                else:
                    # 文本格式
                    template = f.read()
                
                template_name = os.path.splitext(os.path.basename(file_path))[0]
                self.add_template(template_name, template)
                self.set_default_template(template_name)
        except json.JSONDecodeError as e:
            raise PromptTemplateError(f"JSON 解析失败: {file_path} - {e}")
        except Exception as e:
            raise PromptTemplateError(f"加载模板文件失败: {file_path} - {e}")

    def list_templates(self) -> list:
        """列出所有可用的模板名称
        
        Returns:
            模板名称列表
        """
        all_templates = list(self._templates.keys()) + list(self._json_templates.keys())
        return all_templates
    
    def get_template_format(self, template_name: Optional[str] = None) -> str:
        """获取模板的格式类型
        
        Args:
            template_name: 模板名称，如果为 None 则返回默认模板的格式
            
        Returns:
            "json" 或 "string"
        """
        name = template_name or self.default_template
        if name in self._json_templates:
            return "json"
        elif name in self._templates:
            return "string"
        else:
            raise PromptTemplateError(f"模板不存在: {name}")